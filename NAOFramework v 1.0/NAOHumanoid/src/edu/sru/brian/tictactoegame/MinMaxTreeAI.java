package edu.sru.brian.tictactoegame;

import java.io.File;

import edu.sru.brian.tictactoegame.decisiontree.DecisionTreeFromXML;
import edu.sru.brian.tictactoegame.decisiontree.DefaultGenerateDescisionTree;
import edu.sru.brian.tictactoegame.decisiontree.TTTGameData;
import edu.sru.brian.tictactoegame.decisiontree.narytree.NaryTree;

/**
 * File: MinMaxTreeAI.java
 * @author Brian Atwell
 * Description: This uses generated decision tree generated by 
 * {@link DefaultGenerateDescisionTree} it walks through the tree. 
 *
 */
public class MinMaxTreeAI implements AIInterface {
	
	private NaryTree root;
	private NaryTree walk;
	private String initTreeFile;
	private String basePath;
	private boolean isFirst=false;
	
	public static final String DEFAULT_FILE_NAME = DefaultGenerateDescisionTree.BASE_DIR+"xDataTree_Xtop.xml";
	
	/**
	 * Default constructor
	 */
	public MinMaxTreeAI()
	{
		root = new NaryTree(TTTGameData.ROOT);
	}
	
	/**
	 * Constructor
	 * Sets the default path for the decision tree.
	 * @param String fileName
	 */
	public MinMaxTreeAI(String fileName)
	{
		root = new NaryTree(TTTGameData.ROOT);
		setFileName(fileName);
	}
	
	/**
	 * Sets the default path for the decision tree.
	 * @param String fileName
	 */
	public void setFileName(String fileName)
	{
		initTreeFile=fileName;
		File fileObj = new File(initTreeFile);
		int index;
		index = fileObj.getAbsolutePath().lastIndexOf(fileObj.getName());
		basePath = fileObj.getAbsolutePath().substring(0, index);
		System.out.println("BASE PATH: "+basePath);
	}
	
	/**
	 * Load the starting tree
	 */
	public void loadTree()
	{
		if(initTreeFile != null && !initTreeFile.isEmpty())
		{
			DecisionTreeFromXML xml = new DecisionTreeFromXML(initTreeFile);
			root = xml.getStartNode();
			reset();
		}
	}

	/**
	 * Called when it is the AI players turn. Pass in the Game of Tic Tac Toe,
	 * The Opponent's marker and the opponent's move as a 1 Dimensional position
	 * of the board.
	 * @param game
	 * @param oppMark
	 * @param oppMove
	 * @return
	 */
	@Override
	public int calculateNextMove(Game game, Markers oppMark, int oppMove) {
		if(oppMove == -1 && game.getBoardModel().getMarkedCount()==0)
		{
			isFirst=true;
			System.out.println("Made it to the first move");
			//Take our first move
			TTTGameData curData;
			TTTGameData maxWinData;
			NaryTree maxWinNode;
			long maxGain;
			long curGain;
			
			if(!walk.children().isEmpty())
			{
				maxWinNode = walk.children().get(0);
				maxWinData = (TTTGameData) maxWinNode.value();
				maxGain =maxWinData.getLosses()-maxWinData.getWins();
				
				for(int i=1;i<walk.children().size();i++)
				{
					curData = (TTTGameData)walk.children().get(i).value();
					curGain = curData.getLosses()-curData.getWins();
					System.out.println("node: "+i+" Gain:"+curGain);
					if(maxGain<curGain)
					{
						maxWinData=curData;
						maxWinNode=walk.children().get(i);
						maxGain=curGain;
					}
				}
				
				walk = maxWinNode;
				
				curData = (TTTGameData)walk.value();
				
				curData.loadChildren(walk,basePath);
				
				System.out.println("AI Choose: "+curData.getPosition());
				
				return curData.getPosition();
			}
		}
		else
		{
		
		if(isFirst) 
		{
			System.out.println("Made it to the first move");
			TTTGameData curData;
			TTTGameData maxWinData;
			NaryTree maxWinNode;
			long maxGain;
			long curGain;
			
			for(int i=0;i<walk.children().size();i++)
			{
				curData = (TTTGameData)walk.children().get(i).value();
				if(curData.getPosition()==oppMove)
				{
					walk = walk.children().get(i);
					break;
				}
			}
			curData = (TTTGameData)walk.value();
			
			curData.loadChildren(walk,basePath);
			
			if(!walk.children().isEmpty())
			{
				maxWinNode = walk.children().get(0);
				maxWinData = (TTTGameData) maxWinNode.value();
				maxGain = maxWinData.getLosses()-maxWinData.getWins();
				
				for(int i=1;i<walk.children().size();i++)
				{
					curData = (TTTGameData)walk.children().get(i).value();
					curGain = curData.getLosses()-curData.getWins();
					if(maxGain<curGain)
					{
						maxWinData=curData;
						maxWinNode=walk.children().get(i);
						maxGain=curGain;
					}
				}
				
				walk = maxWinNode;
				
				curData = (TTTGameData)walk.value();
				
				curData.loadChildren(walk,basePath);
				
				System.out.println("AI Choose: "+curData.getPosition());
				
				return curData.getPosition();
			}
		}
		else
		{
			TTTGameData curData;
			TTTGameData maxWinData;
			NaryTree maxWinNode;
			long maxGain;
			long curGain;
			
			for(int i=0;i<walk.children().size();i++)
			{
				curData = (TTTGameData)walk.children().get(i).value();
				if(curData.getPosition()==oppMove)
				{
					walk = walk.children().get(i);
					break;
				}
			}
			curData = (TTTGameData)walk.value();
			
			curData.loadChildren(walk,basePath);
			
			if(!walk.children().isEmpty())
			{
				maxWinNode = walk.children().get(0);
				maxWinData = (TTTGameData) maxWinNode.value();
				maxGain = maxWinData.calculateGain();
				
				for(int i=1;i<walk.children().size();i++)
				{
					curData = (TTTGameData)walk.children().get(i).value();
					curGain = curData.calculateGain();
					if(maxGain<curGain)
					{
						maxWinData=curData;
						maxWinNode=walk.children().get(i);
						maxGain=curGain;
					}
				}
				
				walk = maxWinNode;
				
				curData = (TTTGameData)walk.value();
				
				curData.loadChildren(walk,basePath);
				
				System.out.println("AI Choose: "+curData.getPosition());
				
				return curData.getPosition();
			}
		}
		}
		return 0;
	}

	/**
	 * Called when the game class is reset.
	 */
	@Override
	public void reset() {
		// TODO Auto-generated method stub
		if(walk != null && root != null)
		{
			while(walk!=root && (walk.parent()!=null || walk.parent() != NaryTree.EMPTY))
			{
				walk.removeAllChildren();
				walk = walk.parent();
			}
		}
		walk=root;
		isFirst=false;
	}

}
